# Company_Order_Control_System



## System Version 1.0

### 1.	Database Design

#### 1 The snapshot of the E-R diagram generated by DataGrip：

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Version1.0/Part%232/pic.png?token=GHSAT0AAAAAAB6ESP35NK6DQ52SEQRFRLD6Y66QMLQ" style="zoom: 50%;" />

#### 2 Briefly describe the table designs and the meanings of each table and column：

Using **orders** as an index, many-to-one connection of **product**, **contract** and **salesman** means that each **product**, **contract** and **salesman** corresponds to multiple **orders**; 

Under a contract, many-to-one connection of customers (enterprise) means that each customer corresponds to multiple contracts; 

The primary key of the relation table is industry, and the customer many-to-one connection relation table means that each industry corresponds to multiple customer; 

Finally, the supply center connects relation and salesman one-to-many, which means that each salesman has a fixed supply center, and each customer also has a fixed supply center, and they are all in a many-to-one relationship. 



### 2.	Data Import

#### 1 script code

Please see attachment for details.(Load.java, Load2.java)

#### 2 Script introduction and analysis

**Method1** :Continuously import data through JDBC insert statements.(Load.java)

1 Download the JDBC driver for PostgreSQL, and import the jar package into the project through project structure-dependencies; prepare the pre-import file. 

2 Prepare the host, database, user, and password needed to connect to the database, and pass in the openDB method. 

3 openDB method: The purpose is to connect to the database and determine whether it can be successfully connected. First, try to load the Driver class to check whether it can be successfully registered in the DriverManager class; If successful, continue to create the url according to the jdbc protocol ("jdbc:postgresql://" + host + "/" + dbname); If successful, continue to execute Connection con = DriverManager.getConnection(url, props), this step is trying to connect to the database; If all the executions are successful, the database connection is successful. Subsequent interaction with the database can be performed using the Connection object. 

4 Test the openDB method once and execute some simple static Statement objects, that is, execute some SQL statements that need to be executed. 

5 Execute openDB again, and use PreparedStatment to preload the statements that need to be called multiple times to facilitate subsequent processing. 

6 Read the csv data line by line, and perform logical sorting in jdbc, execute the statement through the PreparedStatment object prepared in advance, and import different tables; at the same time, count the time. 

7 Close the database.

**Method2** :Run the copy command through JDBC's CopyManager.(Load2.java) 

1 Same as method1, download the JDBC driver for PostgreSQL, and then import; prepare the host, database, user, and password, create the connection: Connection con = DriverManager.getConnection(url, props). 

2 Get the object of copyManager through the obtained connection(CopyManager copyManager = new CopyManager((BaseConnection) connection);) 

3 Split the files you need to import and match them to the prepared table format.  

4 Execute copyIn method to import data.

#### 3 Script optimization

##### Optimization point1:

Execute the delete foreign key statement first, import data, and create a foreign key after the import is completed. 

**Reason**: 

In the process of importing data, jdbc will check whether the foreign key of each inserted data has a corresponding primary key; thus increasing consumption.

**Code:**

After the first openDB, insert the statement:

```java
Statement statement =connection.createStatement();
statement.execute("alter table relation drop constraint
relation_supply_center_id_fkey cascade ;\n" + 
"alter table salesman drop constraint salesman_supply_center_id_fkey cascade ;\n" + "alter table customer drop constraint customer_industry_id_fkey cascade ;\n" + "alter table contract drop constraint contract_customer_id_fkey cascade ;\n" + "alter table orders drop constraint orders_contract_number_fkey cascade ;\n" + "alter table orders drop constraint orders_product_code_fkey cascade ;\n" + "alter table orders drop constraint orders_salesman_number_fkey cascade ;\n");
```

Thus deleting the foreign key; after the last openDB, insert the statement:

```java
Statement statement2 =connection.createStatement();
statement2.execute("alter table relation add foreign key
(supply_center_id) references supplyCenter(supply_center_id);\n" +
"alter table salesman add foreign key (supply_center_id)
references supplyCenter(supply_center_id);\n" +
"alter table customer add foreign key (industry_id) references
relation(industry_id);\n" +
"alter table contract add foreign key (customer_id) references
customer(customer_id);\n" +
"alter table orders add foreign key (salesman_number) references
salesman(salesman_id);\n" +
"alter table orders add foreign key (contract_number) references
contract(contract_id);\n" +
"alter table orders add foreign key (product_code) references
product(product_id);");
```

Reinsert the foreign key.



##### Optimization point2: 

Run the drop index statement, import data, and then create indexe. 

**Reason:** 

Index helps greatly increase query speed, but affects insert speed. Because in the process of adding data, the corresponding index entries need to be updated in real time. Therefore, deleting indexes before inserting data can improve the speed.  

**Code:** 

After the first openDB, insert the statement:

```java
Statement stmt0 = con.createStatement();
stmt0.execute("drop index product_index;\n" + "drop index supplyCenter_index;\n" + "drop index relation_index;\n" + "drop index customer_index;\n" + "drop index salesman_index;\n" + "drop index contract_index;\n" + "drop index orders_index;");
con.commit();
```

Thus droping the index; after the last openDB, insert the statement:

```java
stmt0.execute("create index product_index on
product(product_id);\n" +"create index supplyCenter_index on supplyCenter(supply_center_id);\n" + "create index relation_index on
relation(industry_id);\n" + "create index customer_index on
customer(customer_id);\n" + "create index salesman_index on
salesman(salesman_id);\n" + "create index contract_index on
contract(contract_id);\n" + "create index orders_index on orders(order_id);");
con.commit();
```

Reinsert the index.



### 3.	Result

Test with computer with: 

Processor: AMD Ryzen 7 4800H with Radeon Graphics, 2.90 GHz 

Memory:16.0 GB(16384MB) RAM

For **method 1**, Without using index, using foreign key -> delete foreign key before inserting and add foreign key after inserting. Speed improvement: 20202 pieces/second -> 43327 pieces/second, more than double the speed.

With deleting foreign key, use index when inserting -> droping index before inserting and add index after inserting. Speed improvement: 32341 pieces/second -> 42808 pieces/second.

| Method                     | Without method  | Use method       |
| -------------------------- | --------------- | ---------------- |
| Method 1 - has foreign key | 20202 records/s | 43327 records/s  |
| Method 1 - no foreign key  | 32341 records/s | 42808 records/s  |
| Method 2 - has foreign key | 41220 records/s | 137741 records/s |
| Method 2 - no foreign key  | 90909 record/s  | 135869 records/s |

For **method 2**, Without using index, using foreign key -> delete foreign key before inserting and add foreign key after inserting. Speed improvement: 41220 pieces/second -> 137741 pieces/second, more than three times faster.

With deleting foreign key, use index when inserting -> droping index before inserting and add index after inserting. Speed improvement: 90909 pieces/second -> 135869 pieces/second.

We can see that the first method is two to three times faster than the second method; After the optimization of foreign keys, the speed of the two methods is increased by 2-3 times. After the optimization of index, the speed of the two methods is increased by about 1.5 times.



### 4.	GUI - ver1.0

##### 1. Login frame

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Pics/Login.png?token=GHSAT0AAAAAAB6ESP343CNTYAGHDAPQIVAWY66QH3A" style="zoom:67%;" />

**Explanation**: The user level mechanism is implemented. After successful login, different rights management will be carried out according to different user levels. In order to prevent malicious users from bypassing the system and modifying the database files by other means, the system adopts two sets of account systems. The account of this system cannot log in and modify the database in any other way.

##### 2. Main frame

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Pics/MultSelect.png?token=GHSAT0AAAAAAB6ESP34CPFO7D4BFYWK5QRUY66QL5Q" style="zoom:67%;" />

**Explanation**: The upper left corner of the interface will display the current user level. Ordinary users can only perform query operations, and administrator users can perform operations such as inquiries, additions, deletions, and changes. Add, modify, and delete operations are based on query operations, and the object of the operation is the result set of the previous query. When the user is a normal user, the operation area below is unavailable.

**Explanation**: The system supports three query search - accrucate search, blurry search and range search.

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Pics/Superviser.png?token=GHSAT0AAAAAAB6ESP35DOSE3X5EEW6GYYLYY66QI4Q" style="zoom:67%;" />

**Explanation**: To prevent miss-operation, after selecting the delete function, you must enter "sure" to confirm the operation. The delete operation is completed and the selected data is successfully deleted. To modify the data, you need to enter the modification result in the operation bar below, and the system will judge whether it is legal and modify it. To modify the data, you need to enter the modification result in the operation bar below, and the system will judge whether it is legal and modify it.



## System Version 2.0

In this version, the system support several APIs which could make managers operator work more efficiently.

### 1.	API Description

#### 0) Using MyBatis，creating classes for evey table and their DAO file to implement basic sql sentence.

```java
public class center {} 			public interface centerDAO {}
public class contract {} 		public interface contractDAO {}
public class enterprise {} 		public interface enterpriseDAO {}
public class model {} 			public interface modelDAO {}
public class orders {} 			public interface ordersDAO {}
public class product {} 		public interface productDAO {}
public class staff {} 			public interface staffDAO {}
```

DAO file implements basic add, delete, query and update for every table, which is used for service label.

#### 1) APIs for manipulating the original data:

This module is used to operate some simple operator such as select, delete, update and insert. （table center as example，insert as example）

```java
public interface BasicCenterService {}
public class BasicCenterServiceImpl{
	public boolean add(center center);
	public boolean delete(int id);
	public center query(int id);
	public boolean change(center center);
}
	<insert id="insertCenter">
		insert into center(id,name)
		values (#{id}, #{name})
	</insert>
```

#### 2) stock In

This module is used to stock product item in table product.

```java
public interface stockInService2 {
public void stockIn(int id, String supply_center, String product_model, int supply_staff,String date, int purchase_price, int quantity)
}
public class stockInService2impl {
	public static void stockIn(int id, String supply_center, String product_model, int supply_staff,
String date, int purchase_price, int quantity) {
		SqlSession sqlSession = MyBatisUtil.getSqlSession();
		mixDAO mixDAO = sqlSession.getMapper(mixDAO.class);
		//....
}
```

#### 3) Others

Please look at "CS307 Project2 Database Application 4-26.pdf".



### 2.	Database Design

Four Basic Tables: staff, enterprise, center, model. 

Three self-made tables: product, orders, contract. 

Create seven tables in the database, directly import the data of four basic tables, and then operate three self_made tables based on the basic data in the database. 

The three tables are empty at the beginning. StockIn filters and imports data into product, and may update product according to different information. 

The placeOrder method filters and imports data to Orders to add orders, and determines whether a Contract exists and imports data to a Contract. 

The updateOrder method filters and updates the Orders table; 

DeleteOrder prevents a judgment and deletes the Orders table.

The remaining methods are select-related methods, so I won't go into details here.





### 3.	GUI - ver2.0

##### 1.)	Pie chart

In different account level, the pie chat would show different information. For manager, it will show the market share of different suppliers. And for salesman, it will show the rate of his finished orders.

##### 2.)	One key to show the statistic information

When the account is manager level, the system could output the statistic information by one key.

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Pics/statistics.jpg?token=GHSAT0AAAAAAB6ESP34RAUW46AGCSWLGHLSY66QLTA" style="zoom: 50%;" />

##### 3.)	Show complex information searched by contract number

Now the system could show complex information searched by contract number. The information are from 5 different tables.

<img src="https://raw.githubusercontent.com/Kazawaryu/Company_Order_Control_System/main/Pics/index.jpg?token=GHSAT0AAAAAAB6ESP35GRS6DCKMT2UNGFGCY66QKEA" style="zoom:50%;" />
